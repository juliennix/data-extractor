/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package com.sudosan

import com.google.gson.Gson
import com.sudosan.App.Companion.dependencyStructure
import com.sudosan.entity.java.ClassMetadata
import com.sudosan.entity.java.InternalPackage
import com.sudosan.grammar.Java8Lexer
import com.sudosan.grammar.Java8Parser
import com.sudosan.model.DependencyStructure
import com.sudosan.model.FileRepresentation
import org.antlr.v4.runtime.CharStreams
import org.antlr.v4.runtime.CommonTokenStream
import org.antlr.v4.runtime.tree.ParseTreeWalker
import org.neo4j.ogm.config.Configuration
import org.neo4j.ogm.session.SessionFactory
import java.io.File
import java.io.InputStream


class App {
    companion object {
        var dependencyStructure: DependencyStructure? = null
    }

    val configuration: Configuration = Configuration.Builder()
            .uri("bolt://neo4j:password@localhost:7687")
            .build()

    val greeting: String
        get() {
            return "Data extractor is extracting the data (yeah)"
        }
}

const val packageEntityName = "com.sudosan.entity"

fun main(args: Array<String>) {
    println(App().greeting)

    for (arg in args) {
        dependencyStructure = buildDependencyForFileWithAntlr(arg)
    }
    println(dependencyStructure)

    writeJsonFile()

    dependencyStructure?.fileToMetadata?.forEach { (key: String) ->
        val classMetadata = ClassMetadata()
        val internalPackage = InternalPackage(dependencyStructure?.fileToMetadata?.get(key)?.packageName)
        internalPackage.addClass(classMetadata)
        classMetadata.internalPackage = internalPackage
        classMetadata.className = key
        classMetadata.importsAll(dependencyStructure?.fileToMetadata?.get(key)?.imports)
        saveClassMetaData(classMetadata)
    }
}

private fun writeJsonFile() {
    val gson = Gson()
    val jsonString: String = gson.toJson(dependencyStructure)
    val dependencyFilePath = "./dependency.json"
    val file = File(dependencyFilePath)
    file.writeText(jsonString)
}


private fun saveClassMetaData(classMetadata: ClassMetadata) {
    val sessionFactory = SessionFactory(App().configuration, packageEntityName)
    val session = sessionFactory.openSession()

    session.save(classMetadata)

    session.load(ClassMetadata::class.java, classMetadata.className)

    sessionFactory.close()
}


private fun extractMetaData(javaClassContent: String): MetaDataListener {
    val (tree, walker) = initAntlr(javaClassContent)
    val metaDataImport = MetaDataListener()

    walker.walk(metaDataImport, tree)

    return metaDataImport
}

private fun initAntlr(javaClassContent: String): Pair<Java8Parser.CompilationUnitContext, ParseTreeWalker> {
    val java8Lexer = Java8Lexer(CharStreams.fromString(javaClassContent))

    val tokens = CommonTokenStream(java8Lexer)
    val parser = Java8Parser(tokens)
    val tree = parser.compilationUnit()

    val walker = ParseTreeWalker()
    return Pair(tree, walker)
}

fun buildDependencyForFileWithAntlr(fileName: String): DependencyStructure {
    val dependencyStructure = DependencyStructure(hashMapOf())
    val fileExtensionToAnalyse = "java"
    File(fileName).walkTopDown().forEach { file ->
        if (file.extension == fileExtensionToAnalyse) {
            dependencyStructure.fileToMetadata[file.name] = FileRepresentation()
            val inputStream: InputStream = file.inputStream()
            val javaClassContent = inputStream.bufferedReader().use { it.readText() }
            val extractedMetaData = extractMetaData(javaClassContent)
            dependencyStructure.fileToMetadata[file.name]!!.imports = extractedMetaData.imports
            dependencyStructure.fileToMetadata[file.name]!!.packageName = extractedMetaData.packageName
        }
    }
    return dependencyStructure
}
